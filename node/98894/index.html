<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Python Script - Find all selected glyphs | Typophile Archive</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="">
    <meta name="generator" content="Hugo 0.91.2" />
    
    
    
    
      <meta name="robots" content="noindex, nofollow">
    

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p" crossorigin="anonymous"></script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <link href="/style.css" rel="stylesheet">

    <meta property="og:title" content="Python Script - Find all selected glyphs" />
<meta property="og:description" content="" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://typophile.github.io/node/98894/" /><meta property="article:section" content="node" />
<meta property="article:published_time" content="2012-12-13T03:41:52+00:00" />
<meta property="article:modified_time" content="2012-12-13T03:41:52+00:00" />

<meta itemprop="name" content="Python Script - Find all selected glyphs">
<meta itemprop="description" content=""><meta itemprop="datePublished" content="2012-12-13T03:41:52+00:00" />
<meta itemprop="dateModified" content="2012-12-13T03:41:52+00:00" />
<meta itemprop="wordCount" content="0">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Python Script - Find all selected glyphs"/>
<meta name="twitter:description" content=""/>

  </head>

  <body class="ma0">

      <header>
  <nav class="navbar navbar-expand-lg navbar-light bg-light">
    <div class="container">
      <a class="navbar-brand" href="/">Typophile Archive</a>
      <button
        class="navbar-toggler"
        type="button"
        data-bs-toggle="collapse"
        data-bs-target="#navbarSupportedContent"
        aria-controls="navbarSupportedContent"
        aria-expanded="false"
        aria-label="Toggle navigation"
      >
        <span class="navbar-toggler-icon"></span>
      </button>
    </div>
  </nav>
</header>
 
    <main role="main">
      
<article class="container">
  <header class="post-header py-3">
    <h1 class="post-title p-name" itemprop="name headline">Python Script - Find all selected glyphs</h1>
    <p class="text-muted">
              
      <time class="f6 mv4 dib tracked" datetime="2012-12-13T03:41:52Z">December 13, 2012</time>
      
        
          • <span itemprop="author" itemscope itemtype="http://schema.org/Person">
            <span class="p-author h-card" itemprop="name">
            <a href="/?q=author:Kannery">
            Kannery
	    </a>
        </span></span>
      

    </p>
  </header>
  <div class="post-content e-content" itemprop="articleBody"><p>I&rsquo;m trying to write a simple python script that acts on the glyphs that the user has selected in the FontLab font window:</p>
<img src="http://typophile.com/files/glyph-slots.png" />
<p>I&rsquo;m especially interested in the glyphs (or maybe more accurately &ldquo;glyph slots&rdquo;) that are in the encoding but are un-filled.</p>
<p>So far I&rsquo;ve tried two things:</p>
<code>
# 1 - glyph slots
selectedSlots = fl.count_selected
print "Number of selected glyph slots:", selectedSlots
</code>
<code>
# 2 - selected glyph names
selectedNames = [ fl.font.glyphs[i].name for i in range(len(fl.font.glyphs)) if fl.Selected(i) ]
print "List of selected glyph names:", selectedNames
</code>
<p>Script number 1 reports a count of the full user selection - all selected glyph slots - filled and un-filled - perfect! Script number 2 returns a list of glyphnames but only the selected glyphs that are filled - no good. Results of running 1 and 2:</p>
<code>
Number of selected glyph slots: 3
List of selected glyph names: ['eacute']
</code>
<p>Can anyone suggest a technique that will list the glyphnames associated with all the selected glyph slots?</p>
<p>cheers</p>
<ul>
<li>kannery</li>
</ul>
</div>

  
  <img src="/images/old-images/glyph-slots.png" class="img-fluid">
  
   <div class="comment card m-3">
	<div class="card-body">
		<div class="commentbody">If a slot is empty, there is nothing in FontLab to read.</div>
	</div>
	<div class="card-footer text-muted post-meta text-end">
		<time
			class="dt-published"
			datetime="2012-12-16 02:40:23"
			itemprop="datePublished"
		>
			2012-12-16 02:40:23
		</time>
		•
		<span itemprop="author" itemscope itemtype="http://schema.org/Person">

			<span class="p-author h-card" itemprop="name">
            <a href="/?q=author:malcolm">
            malcolm
	    </a>
			</span></span>
	</div>
	
</div>
  <div class="comment card m-3">
	<div class="card-body">
		<div class="commentbody"><p>FontLab can read the glyphnames associated with the slots, even if they are empty:</p>
<code>
# Generate a list of encoding glyph names
enc = fl.font.encoding
encodingNames = [ enc[i].name for i in range(len(enc)) ]
print "List of the encoding glyph names:", encodingNames
</code>
<code>
List of the encoding glyph names:
['acute', 'aacute', 'eacute', 'iacute', 'oacute', 'uacute', 'yacute', 'cacute']
</code>
<p>And even if the slots are empty, FontLab also knows how many slots are selected (see script #1 in my first post). So possibly there is a way for FontLab to associate glyphnames with selected slots &ndash; empty or not.</p>
<p>I hope. Is there a way?</p>
<p>cheers
-k</p>
</div>
	</div>
	<div class="card-footer text-muted post-meta text-end">
		<time
			class="dt-published"
			datetime="2012-12-16 08:43:29"
			itemprop="datePublished"
		>
			2012-12-16 08:43:29
		</time>
		•
		<span itemprop="author" itemscope itemtype="http://schema.org/Person">

			<span class="p-author h-card" itemprop="name">
            <a href="/?q=author:Kannery">
            Kannery
	    </a>
			</span></span>
	</div>
	 <div class="comment card m-3">
	<div class="card-body">
		<div class="commentbody"><p>&lt;FontLab can read the glyphnames associated with the slots, even if they are empty:&gt;</p>
<p>No it can&rsquo;t. Your script is reading an encoding not the font data.</p>
</div>
	</div>
	<div class="card-footer text-muted post-meta text-end">
		<time
			class="dt-published"
			datetime="2013-01-01 18:57:02"
			itemprop="datePublished"
		>
			2013-01-01 18:57:02
		</time>
		•
		<span itemprop="author" itemscope itemtype="http://schema.org/Person">

			<span class="p-author h-card" itemprop="name">
            <a href="/?q=author:malcolm">
            malcolm
	    </a>
			</span></span>
	</div>
	
</div>
 
</div>
  <div class="comment card m-3">
	<div class="card-body">
		<div class="commentbody"><p>I don&rsquo;t use Fontlab (I use mainly FontForge); it seems to me you are trying to list names of characters that are not in the font. What you can do is determine the unicode range of those characters that are in the font and then print the names given by the encoding. If the first and last character are in the font then the following code seems to work on my demo version of Fontlab</p>
<PRE>
def encodingNames():
  gl = fl.font.glyphs
  sIndices = [ g.unicode 
     for g in gl if fl.Selected(g.index) ]
  eNames = [ enc[i].name 
     for i in range(sIndices[0],sIndices[-1]+1) ]
  return eNames
print "List of glyph names in the selected range:", encodingNames()
</PRE>
</div>
	</div>
	<div class="card-footer text-muted post-meta text-end">
		<time
			class="dt-published"
			datetime="2012-12-16 15:41:22"
			itemprop="datePublished"
		>
			2012-12-16 15:41:22
		</time>
		•
		<span itemprop="author" itemscope itemtype="http://schema.org/Person">

			<span class="p-author h-card" itemprop="name">
            <a href="/?q=author:Michel&#43;Boyer">
            Michel Boyer
	    </a>
			</span></span>
	</div>
	
</div>
  <div class="comment card m-3">
	<div class="card-body">
		<div class="commentbody"><p>Thanks for your suggestion Michel, its an interesting script. But unfortunately your script would only work for me in a very rare special case: if the user happens to select a filled slot with an ID thats numerically lower than any unfilled selected slot AND, at the same time, the user also happens to select another filled slot with an ID thats numerically higher than any selected unfilled slot.</p>
<p>Its just too narrow of a scenario, but your script does give some inspiration for crafty workarounds, so thanks.</p>
<p>I guess what I&rsquo;m after would be a magical method where you could probe for glyphnames like this:</p>
<code>
fl.font.encoding.Selected(glyphname)
</code>
<p>Where it would return TRUE if the encoding slot was selected.</p>
<p>cheers,
-k</p>
</div>
	</div>
	<div class="card-footer text-muted post-meta text-end">
		<time
			class="dt-published"
			datetime="2012-12-16 21:45:40"
			itemprop="datePublished"
		>
			2012-12-16 21:45:40
		</time>
		•
		<span itemprop="author" itemscope itemtype="http://schema.org/Person">

			<span class="p-author h-card" itemprop="name">
            <a href="/?q=author:Kannery">
            Kannery
	    </a>
			</span></span>
	</div>
	
</div>
  <div class="comment card m-3">
	<div class="card-body">
		<div class="commentbody"><p>I came up with a workaround:</p>
<pre>
# Find all selected glyph slots

f = fl.font
s1 = [ g.name for g in f.glyphs if fl.Selected(g.index) ]
slots = [ e.name for e in f.encoding if e.unicode > -1 ]
empties = [ n for n in slots if not f.has_key(n) ]

# Create temporary blank glyphs in all empty glyph slots
for n in empties:
	g = Glyph()
	g.name = n
	f.glyphs.append(g)
fl.UpdateFont()

s2 = [ n for n in empties if fl.Selected(f[n].index) ]

# Remove temporary blank glyphs
for n in empties:
	del(f.glyphs[f[n].index])
fl.UpdateFont()

allSelected = s1 + s2
print "All selected slots:", allSelected

</pre>
<p>Using the example from my first post, the user has selected one full glyph slot [eacute] and two empty glyph slots [uacute, yacute] :</p>
<img src="http://typophile.com/files/glyph-slots.png"> 
<p>Running the script in this state yields the result:</p>
<pre>
All selected slots: [eacute, uacute, yacute]
</pre>
<p>A kludgy script, but it gets the job done. If anyone has a more elegant solution, please post ( Adam? Eigi? ).</p>
<p>cheers,
-kannery</p>
</div>
	</div>
	<div class="card-footer text-muted post-meta text-end">
		<time
			class="dt-published"
			datetime="2013-01-03 07:44:42"
			itemprop="datePublished"
		>
			2013-01-03 07:44:42
		</time>
		•
		<span itemprop="author" itemscope itemtype="http://schema.org/Person">

			<span class="p-author h-card" itemprop="name">
            <a href="/?q=author:Kannery">
            Kannery
	    </a>
			</span></span>
	</div>
	
</div>
 
</article>

    </main>
    
  </body>
</html>
