---
author:
  name: Frode Bo Helland
  picture: 112295
body: "I just came across [[http://www.bramstein.com/projects/typeset/|this]]. It\u2019s
  a really interesting idea. He use a javascript algorithm to manipulate the inter-word
  spacing.\r\n\r\nBelow: A screen shot from Opera/OSX (Firefox/OSX is not working
  correctly yet).\r\n[img:sites/default/files/old-images/ex_5129.png]\r\n"
comments:
- author:
    name: blank
  body: "The difference is quite noticeable, and in this example, in TypeSet\u2019s
    favor. And of course, this raises an interesting question about H&J on the web\u2014should
    it be done by the browser, or should designers have more control as they do in
    print?"
  created: '2010-06-11 01:02:30'
- author:
    name: Frode Bo Helland
    picture: 112295
  body: "Thing is, depending on the device it\u2019s displayed on and the users settings
    the width of a text block will vary. That is the nature of the web, but also what
    gives it it\u2019s unique quality. \r\n\r\nI\u2019d love to see this as a CSS
    feature, with desired justification specified as a percentage number or a few
    level keywords like for example \u201Ctight\u201D, \u201Cnormal\u201D and \u201Cloose\u201D.
    \r\n\r\nfont-align: justify; \r\ndesired-justification: 90%;\r\n\r\nIt would have
    to be smart enough to adjust the percentage according to the width, though."
  created: '2010-06-11 01:24:43'
- author:
    name: Richard Fink
    picture: 117375
  body: "@frode\r\n\r\n<em>By \u201Csmart\u201D I\u2019m thinking it should be able
    to detect the width of the block and adjust the desired percentage accordingly.</em>\r\n\r\nThanks
    for this. I've done quite a bit of experimentation with H&J in browsers but I
    never really thought about handling the column width (measure) as a \"liquid\"
    variable before now. Just fixed-width. (In pixels at least, which isn't physically
    fixed like print.) There is probably some ratio that can be determined.\r\n\r\n@james
    puckett\r\n<em>And of course, this raises an interesting question about H&J on
    the web\u2014should it be done by the browser, or should designers have more control
    as they do in print?</em>\r\n\r\nAs far as justification, there's already quite
    a lot of control using the CSS word-spacing and letter-spacing properties along
    with either the HTML spacer entities or the Unicode general punctuation spaces.
    (But the font needs to have them to use them.) These things in combination will
    give control down to the pixel level, at least. Just tightening or loosening the
    word-spacing can have a big effect. In a print style sheet, where things don't
    have to be rounded for the raster grid, I would imagine you get about as much
    control as you can in any app. (Gotta test that, though. Never checked.)\r\nAs
    far as hyphenation, the soft hyphen is supported now in every major browser and
    there's a javascript implementation of Franklin M. Liangs hyphenation algorithm
    from LaTex available that works pretty darned well. I suppose a native in-browser
    implementation would be a bit more thorough, but not by much. (I can only vouch
    for how it works for English.)\r\nThe biggest problems I've run into stem from
    how different browsers work with the em unit. Rounding and such. Plus, I've never
    been able to get rid of at least some reflow on Zoom which runs the risk of text
    that looks fine at 100% but sprouts widows and orphans and other undesirables
    at, say, 130%.\r\nAnd then, because soft hyphens are added at every available
    breakpoint, there's also a need to remove them via javascript on cut-and-paste.
    Detecting line endings and placing the soft hyphens more selectively would be
    more elegant, but tough to do cross-browser right now.\r\nIt's a pain. But a lot
    of control <em>is</em> already there with CSS. And whether or not the browser
    handles hyphenation, that won't change."
  created: '2010-06-11 02:33:25'
- author:
    name: Frode Bo Helland
    picture: 112295
  body: I did a late editing there, hence the wrong quote.
  created: '2010-06-11 03:34:03'
- author:
    name: Bram Stein
  body: "Frode told me you were having an interesting discussion here about my line
    breaking implementation so I thought I would chime in. In my opinion justification
    should be done by the browser, preferably with some user defined properties. However,
    this won't be that much of an improvement until browsers also support hyphenation,
    which in turn requires them to know or detect the language of any given page.
    Even though those features won't be implemented any time soon, I believe that
    replacing the current text layout engines with a Knuth and Plass based algorithm
    would increase the quality of justification on the web. The Knuth and Plass line
    breaking algorithm guarantees results no worse than the naive implementation browsers
    currently use.\r\n\r\nIf I remember correctly, Internet Explorer exposes a <a
    href=\"http://msdn.microsoft.com/en-us/library/ms534671(VS.85).aspx\">CSS property</a>
    that affects justification. There is also a proposal for a <a href=\"http://www.w3.org/TR/css3-text/#text-justify\">CSS3
    text-justify property</a>, but it seems they leave the actual justification algorithm
    up to the browser.\r\n\r\nI ran into similar problems as those mentioned by Richard
    Fink. Wrapping each line in an element and setting the word spacing is fragile
    (at best) since there is no way to get reliable font metrics back from the browser.
    Print stylesheets would still need flexible widths as there are different paper
    sizes and orientations, all out of your control. That's the beauty of the web
    :)"
  created: '2010-06-11 13:01:33'
- author:
    name: Khaled Hosny
    picture: 113033
  body: "@ Bram Stein\r\n\r\nOut of curiosity, how much overlap between your code
    and \r\nhttp://code.google.com/p/hyphenator/, since hyphenation and justification
    are closely related, is it possible to combine both works?"
  created: '2010-06-12 18:02:05'
- author:
    name: maxgraphic
    picture: 115146
  body: "Since this uses canvas to render text as a graphic, don't we lose selection/searching/indexing/accessibility?
    As much as I love decent H&J, that's a high price to pay.\r\n"
  created: '2010-06-13 06:52:13'
- author:
    name: Bram Stein
  body: "@Khaled Hosny\r\n\r\nActual code, not so much. It is already possible to
    manually insert hyphenation points in my implementation, and adding hyphenator
    would just automate that process (i.e. the algorithm doesn't need to change, just
    the way the input is generated.) My current implementation just assumes there
    are no legal break points within a word.\r\n\r\n@maxgraphic\r\n\r\nCorrect, this
    example uses canvas for rendering. It is however not limited to canvas. I have
    an implementation lying around that uses the browsers rendering engine, making
    text selectable, etc. I haven't released it, because I think justification should
    be a browser feature and not a JavaScript add-on."
  created: '2010-06-20 21:12:23'
- author:
    name: Richard Fink
    picture: 117375
  body: "@bram stein\r\n\r\nI understand your having an opinion on how and where H&J
    should be deployed, but holding back code seems an odd way to make a statement!
    Anyway, could I perhaps get a look at what you've done?\r\nrfink [..] readableweb.com
    or just post a comment to my blog, readableweb.com.\r\n\r\nIt's going to be a
    long time until we see hyphenation dictionaries within browsers. Meanwhile, JavaScript
    engines have become very fast, and the performance hit is neglegible in comparison
    to network costs - the costs in time of gathering the resources. It takes far
    longer for the browser to layout the page and parse the CSS rules than interpret
    the JS.\r\nLet me know. Thanks.\r\n\r\n<a href=\"http://readableweb.com\">Rich</a>"
  created: '2010-06-21 17:21:26'
- author:
    name: Bram Stein
  body: "@Richard Fink\r\n\r\nPerhaps my statement about not releasing the code came
    out a bit weird. I'm not holding back any code for idealogical reasons. :) I merely
    made a proof-of-concept implementation but never actively promoted it because
    there are some limitations to it. I have now added the proof-of-concept to the
    Typeset page at:\r\n\r\nhttp://www.bramstein.com/projects/typeset/\r\n\r\nThe
    code can be found on my Github page (browser-assist.js):\r\n\r\nhttp://github.com/bramstein/javascript/tree/master/src/typeset/\r\n\r\nWhat
    it does is split a paragraph into lines according to the line breaks found by
    the Knuth and Plass algorithm and then wraps each line in a span element with
    an individual CSS word-spacing attribute.\r\n\r\nThe main problem with this approach---and
    the main reason I think this should be done in the browser---is floating elements
    (i.e. elements that affect the layout of the text.) A JavaScript implementation
    would need to measure the \"shape\" of the text before it can do line breaking.
    As far as I know there is no easy way to get this text \"shape\" back from a browser,
    you can only approximate it by trying to lay out text and see where line breaks
    happen.\r\n\r\nI'm still thinking about an efficient way of solving the above
    problem in JavaScript. If successful it would be possible to create a script that
    fixes both justification and hyphenation until browsers implement it natively.\r\n\r\nAs
    an aside, someone (@lqd on Twitter) combined my Typeset code with hyphenator.js
    and sent me the following screenshots:\r\n* http://twitpic.com/1zdlh6\r\n* http://twitpic.com/1zdh4a"
  created: '2010-06-25 13:45:06'
- author:
    name: Richard Fink
    picture: 117375
  body: "@bram stein\r\nthanks. I'll take a long look. I'm working on code (and an
    accompanying article) about H&J for browsers and it's looking pretty good, frankly.
    (The H&J, that is.)\r\n\r\nI'm not quite sure what you mean by the \"shape\" of
    the text but I'll try to figure that one out. Got your email, BTW.\r\n\r\nOne
    problem I'd like to solve is exactly where the line breaks occur in all browsers.
    You could do it in IE7 but that got re-worked and broken in IE8. And I can proceed
    without it, but it would solve a few remaining problems.\r\n(If anybody has any
    ideas? Please...)\r\n\r\nThanks again.\r\n\r\nrich\r\n"
  created: '2010-06-25 19:19:24'
- author:
    name: Frode Bo Helland
    picture: 112295
  body: Am I missing something, or is this still canvas and non-selectable/searchable?
  created: '2010-06-25 22:32:25'
- author:
    name: Bram Stein
  body: "@frode frank\r\n\r\nSee the \"Assisted browser line breaks\" section and
    below.\r\n\r\n@Richard Fink\r\n\r\nI had a go at a bit more serious implementation
    today:\r\n\r\nhttp://www.bramstein.com/projects/typeset/flatland/flatland.html\r\n\r\nThe
    page contains two texts: the one on the left is justified by your browser, the
    text on the right is justified by my implementation and hyphenated by Hyphenator.js.
    Canvas is not used. Both texts use fonts from Google's Font Directory. I have
    tested it in Firefox, Safari and Chrome, and all seem to work.\r\n\r\nThere are
    some (small) problems but I think most of them can be worked out:\r\n* Selection
    looks ugly (this is to workaround a bug in Webkit that ignores subpixel word-spacing)\r\n*
    Copied and pasted text includes the soft hyphens\r\n* Chrome sometimes executes
    the H&J before activating the font (refreshing usually fixes it.)\r\n* Floating
    elements are not yet supported (that is what I meant with the \"shape\" of the
    text, the line breaking algorithm needs to take the space that floating elements
    take up into account.)\r\n\r\nLoading may look slow, but that is mostly caused
    by downloading the fonts from Google's Font Directory. Only then can the H&J algorithm
    run (as it needs the correct font metrics.)\r\n\r\nWhat exactly do you mean by
    finding where line-breaks occur in all browsers?"
  created: '2010-06-26 16:51:14'
- author:
    name: Frode Bo Helland
    picture: 112295
  body: "It breaks when when you change text size.\r\n\r\n[img:sites/default/files/old-images/ex_3489.png]"
  created: '2010-06-26 17:59:39'
- author:
    name: Bram Stein
  body: "@frode frank\r\n\r\nDon't do that :P\r\n\r\nSeriously though, I think this
    is the result of my \"fix\" for Chrome (Webkit?) which doesn't support subpixel
    word-spacing (it rounds it to the nearest integer.) I hardcoded the spacing between
    words for all browsers to fix it. This will result in strange behaviour when changing
    the text size (and is also the cause of the odd looking selection.) This probably
    wouldn't happen if Chrome supported subpixel word-spacing. I have some other ideas
    on how to attack this particular problem, and hopefully I come up with something
    that works with text size changes. "
  created: '2010-06-26 18:54:22'
- author:
    name: Frode Bo Helland
    picture: 112295
  body: "Sorry, Bram! :) Seriously though, when you start running into more problems
    then you had before you started, it\u2019s usually time to restart the process.
    \r\n\r\nEver seen the roads these guys patch up? It\u2019s sort of like that.\r\n[img:sites/default/files/old-images/asphalt_4746.jpg] "
  created: '2010-06-26 19:02:29'
- author:
    name: Richard Fink
    picture: 117375
  body: "frode>It breaks when when you change text size.\r\n\r\nstein>Don't do that!\r\n\r\nhah!\r\nI've
    run into this one before. This would not be a problem if browsers had a \"zoom\"
    event and/or an \"ontextsizechange\" event. Then you could handle it programatically.
    At least refresh the page or let the reader know what's going on.\r\n\r\n@bram
    stein\r\n<em>Copied and pasted text includes the soft hyphens</em>\r\nThis was
    a deal-killer for me until recently. Got this one figured out. (Not my work but
    I've improved it some.)\r\n\r\nI'll take a closer look at your demo and be back.\r\n\r\nRich\r\n"
  created: '2010-06-26 20:09:04'
- author:
    name: Richard Fink
    picture: 117375
  body: "@bram\r\n\r\nI took a brief look and am still trying to figure out what your
    algorithm does that can't be done just by fiddling with the value of word-spacing.
    In that brief look, I'm having a bit of trouble figuring out exactly what the
    code is doing. (But I'll get back to you on that.)\r\n\r\n>What exactly do you
    mean by finding where line-breaks occur in all browsers?\r\n\r\nAs you know, hyphenator.js
    takes a \"shotgun\" approach and adds soft-hyphens everywhere. But they are only
    visible where the browser breaks the word.\r\nHere's what would be helpful: being
    able to identify only those soft hyphens that the browser displays. (Those breaking
    words at the end of lines.)\r\nI need to identify them because I need to remove
    them, yet preserve the amount of space the soft-hyphen takes up horizontally and
    also preserve the line break. (Sounds odd, I know. Seems I can do the preserving,
    but it's the identifying that's hanging me up. I have an idea I want to try, but
    haven't had the time to write some code and test. But I will.)\r\n\r\nIn the meantime,
    maybe you're smarter than me, any ideas on how to identify only the soft hyphens
    that appear at the end of lines?\r\n\r\n\r\nAlso - do you think your algorithm
    would be useful in preventing widows? (Like I said, I'm still trying to follow
    the logic of your code. Sooner or later I'll firebug it. Or you'll explain!)\r\n\r\nThanks.\r\n\r\nRich"
  created: '2010-06-28 15:07:24'
- author:
    name: Bram Stein
  body: "To understand what my algorithm (or rather the Knuth and Plass algorithm)
    does I need to explain how browsers currently implement justification. Most browsers
    implement justification by employing a first fit strategy (except Internet Explorer
    which uses the Knuth and Plass algorithm if enabled with \"text-justify: newspaper;\".)
    Words are inserted one by one using normal word-spacing. A line break is inserted
    before the first word that doesn't fit on a given line. The browser then adjusts
    the word-spacing on that line so that the line is stretched to the maximum width
    it can have (defined by the width of the text column.) Note that this strategy
    always increases word-spacing, it never decreases. Rivers are created by large
    words at the end of the line that do not fit and are moved to the next line. Large
    word-space values need to make up for that missing word so as to justify that
    line.\r\n\r\nHyphenation can avoid rivers by creating more break points in a line.
    So instead of just being able to insert a line-break between words, hyphenation
    makes it possible to also insert line-break in words (defined by a hyphenation
    algorithm or dictionary.)\r\n\r\nMy JavaScript implementation of the Knuth and
    Plass line breaking algorithm takes over line breaking from the browser. The major
    differences is that instead of just increasing the word-spacing it also allows
    decreasing of word spacing, and instead of basing its line breaking on one line
    it tries to minimize the word-spacing over the whole paragraph. For example, it
    might take a slightly less than optimal word-spacing in one line to prevent an
    even worse word-spacing in the next line. It also tries to prevent two consecutive
    lines from having a too large difference in word-spacing.\r\n\r\nIn my earlier
    Typeset examples I did not consider hyphenation and only focused on justification.
    I have since then added hyphenation using Hyphenator.js. This basically gives
    the algorithm more break-points to work with. The result is an even better justification
    (i.e. closer to the global minimum amount of word-spacing per paragraph.) \r\n\r\nMy
    implementation returns a list of line-break points that represent the global minimum
    of word-spacing. I split the original paragraph by the line-break points and calculate
    the amount of word-spacing required to justify each line. In my first tests I
    just passed the word-spacing as a CSS attribute on a line-by-line basis, but I
    quickly found out that Webkit (Safari & Chrome) do not support word-spacing with
    values less than 1 pixel. The necessary word-spacing is often less than 1 pixel
    so I had to resort to some hacks to fake it. I do this by adding fixed-width spaces.
    It unfortunately does have some side-effects as I mentioned (the strange selections.)\r\n\r\nAs
    my implementation completely replaces the browser's built-in line-breaking it
    knows exactly when and where line-breaks occur. As you can see in the Flatland
    example, I only insert soft hyphens where they are needed.\r\n\r\nPrevention of
    widows ands orphans can be added to the Knuth and Plass line-breaking algorithm
    as an extension. I have not implemented this since I didn't see the need for it
    on a web page. Apart from printing there is plenty of vertical space. Though,
    adding it is about 10 lines of code as my implementation already calculates the
    necessary information---it just ignores it at the moment.\r\n\r\nRegarding the
    detection of line-breaks. I've done something similar on my Typeset page. The
    basic idea is that you iterate through each word in the paragraph and check its
    Y position. If the Y position is different from the previous word, then you know
    the browser has inserted a line break. I'm not sure exactly if that is what you
    are after, but perhaps it is of help."
  created: '2010-06-28 21:07:58'
- author:
    name: Theunis de Jong
    picture: 114717
  body: "<cite>(i.e. closer to the global minimum amount of word-spacing per paragraph.)</cite>\r\n\r\nShouldn't
    that be the global <em>optimal</em> word-spacing?\r\n\r\nAs for 'widows and orphans',
    those are per definition page terms. On a web page, the page vertically never
    ends, so you'll never have to worry about windows or orphans! I think Richard
    may mean 'runts' -- a very short last line of a paragraph. Those can be avoided
    by stopping scanning for feasible breakpoints before the end of the actual paragraph
    is reached."
  created: '2010-06-28 23:16:44'
- author:
    name: Bram Stein
  body: "@Theunis de Jong\r\n\r\nI wrote \"global optimum amount of word-spacing\"
    at first, but then I changed it to \"minimum\" because of the way CSS word-spacing
    works (i.e. it is not an absolute value but an additional value added to the default
    word-spacing, which in the case of CSS should be kept to a minimum.) What I meant
    is that the word-spacing changes should be as close as possible to the default
    word-spacing. You are correct in pointing out that is technically a global optimum.\r\n\r\nI
    think runts are related to widows and orphans as well (at least in the algorithm.)
    The Knuth and Plass algorithm usually finds multiple sets of line-breaks. It would
    be possible to avoid runts by choosing one that might be (slightly) less optimal
    but has one line more or less to avoid single word lines. I think early stopping
    might also work, but I haven't tried that yet.\r\n\r\n"
  created: '2010-06-29 07:41:43'
- author:
    name: Theunis de Jong
    picture: 114717
  body: "Ah, yes: from a point of view of <em>adjustment</em> to space it should be
    as minimal as possible, either positive or negative.\r\n\r\n<cite> It would be
    possible to avoid runts by choosing one that might be (slightly) less optimal
    but has one line more or less to avoid single word lines. I think early stopping
    might also work, but I haven't tried that yet.</cite>\r\n\r\nI don't even know
    why I wrote that down! I was, in fact, thinking of the TeX way: find all breakpoints
    but assign a penalty for the final line length; huge for a very short line, small
    for a rather short line, and perhaps a negative value (\"I want this!\") if it's
    an exceptionally <em>good</em> last line (by some objective definition ...).\r\n\r\nI
    don't think this will need any adjustment of the rest of your code -- i.e., a
    paragraph <em>is</em> typeset optimally if it avoids an ugly runt at the end."
  created: '2010-06-29 10:40:04'
- author:
    name: Bram Stein
  body: "@Theunis de Jong\r\n\r\nThis presentation (given tomorrow) seems relevant:\r\nhttp://tug.org/tug2010/abstracts/rundell.txt\r\n\r\nI'll
    keep an eye on it and see if I can get my hands on a copy."
  created: '2010-06-29 15:55:32'
- author:
    name: Theunis de Jong
    picture: 114717
  body: "Finally! Knuth on this in <em>The TeXbook</em> (1984):\r\n\r\n\"TeX breaks
    lists of lines into pages by computing badness ratings and penalties, more or
    less as it does when breaking paragraphs into lines. But pages are made up one
    at a time and removed from TeX's memory; there is no looking ahead to see how
    one page break will affect the next one. In other words, TeX uses a special method
    to find the optimum breakpoints for the lines in an entire paragraph, but it doesn't
    attempt to find the optimum breakpoints for the pages in an entire document. <em>The
    computer doesn't have enough high-speed memory capacity to remember the contents
    of several pages</em>, so TeX simply chooses each page break as best it can, by
    a process of \"local\" rather than \"global\" optimization.\"\r\n\r\n(my emph.)\r\n\r\n(It's
    possible you already read and memorized every page.)"
  created: '2010-06-29 16:56:04'
- author:
    name: raph
    picture: 109741
  body: "For the record, I think this is a great proof of concept. I've kicked around
    the idea of coding up something similar for a while now, and am very glad that
    someone has finally done it.\r\n\r\nMaking it really useful and usable is hard.
    I'm not sure whether the best path for that is to grind through the slog of fixing
    the problems one by one: (async loading and size-change issues, copy and paste,
    etc, etc), or to advocate for browsers to implement this natively. All I know
    is that I want high quality text layout in my browser before I grow old."
  created: '2010-06-29 21:39:35'
- author:
    name: Bram Stein
  body: "@raph\r\nThanks for the kind words. I see you were also involved with Google's
    font API---very nice work.\r\n\r\nI'm kind of on the side of advocating the browsers
    to implement this natively. I have been looking through the Webkit and Gecko source,
    but I'm not that familiar with either engine internals (that, plus limited time.)
    As you said, I would love to have high quality text layout on the web as well,
    preferably sooner than later.\r\n\r\nFor now I'm trying to see how far I can take
    it in JavaScript. I have fixed some of the bugs I mentioned before: selections
    are working, resizing as well, and copy and paste is no worse than a normal paragraph
    with soft-hyphens in it (these fixes are not yet online though.) The big issue
    remaining is floating items; I'm planning to measure all floating elements I encounter,
    create space for them in the text and absolute position them in the appropriate
    place. The trick is making it generic enough."
  created: '2010-06-30 08:51:36'
- author:
    name: Richard Fink
    picture: 117375
  body: "@bram\r\n\r\nThanks for the explanation. It does help some. And glad to know
    after all these years that text-justify:newspaper in IE is the Knuth-Plass alg.
    Never knew until you told me. Live and learn.\r\n\r\nTheunis is correct - I'm
    more concerned about runts. (And BTW - IE has a widow/orphan preventing CSS property
    for print stylesheets if I remember correctly.)\r\n\r\n[Note: I'm not totally
    free to go into this in depth in a public forum because it's part of a larger
    article and the publisher understandably doesn't want to run the risk of someone
    popping out of nowhere when the thing is published and saying, \"Hey, that was
    published on my blog! Take it down!\" However, any help I get will be duly and
    happily credited and I'm perfectly free to send or publish links to my experiments
    and so I will do that. All info will be published free and clear for anyone to
    use, anyway.]\r\n\r\nI'm convinced that decent H&J is now a practical proposition
    for the web. My instincts tell me that hyphenator.js's shotgun approach (along
    with text-align:justify) is the more flexible approach. The browser engine does
    more of the work. I've been keeping an eye on hyphenator.js for a year and half
    now and Mathias Nater has done an excellent job.\r\nWant to see a case in point?
    Check out the browser-as-e-reader approach at ibisreader.com. Check out the adjustable
    page width feature. Your code would require a complete re-rendering. With hyphenator.js,
    the text would just reflow with the hyphens appearing where they need to be. Similar
    to the text size change issue. With that, too, hyphenator.js presents no problems.
    Floats present no problems, either.\r\n\r\nI've put together a variation of hyphenator.js
    that I'm pretty happy with so far.\r\n1) First, there was the cut and paste problem.
    (That is, if you select the words, \"Helping the homeless\", you get \"Help-ing
    the home-less\". WTF! But it's fixable as it turns out.)\r\n2) My next step will
    be to add a generic CSS selector engine. Probably Sizzle from jQuery. This will
    add a lot more flexibility. So it won't be necessary to add the class \"hyphenate\"
    when there are already enough identifiers in the markup to select the elements
    you want to H&J.\r\n3) After that, there is the problem of the context menu. For
    some reason, the soft hyphens are showing up as spaces. Help ing the home less.
    Another WTF. This too, looks fixable, though.\r\n\r\nAs soon as I've got the selector
    engine cooking, I'll get some test pages up somewhere for input. Maybe find a
    way to tackle the runts.\r\n\r\nThanks much. I'll be back."
  created: '2010-06-30 22:49:57'
- author:
    name: Bram Stein
  body: "@Richard Fink\r\n\r\nFor the record, I do not know for sure that Internet
    Explorer uses the Knuth and Plass algorithm for justification when <code>text-justify</code>
    is set to <code>newspaper</code>. I only compared the justification of my implementation
    with the one created by Internet Explorer, and found them to be identical for
    my sample text.\r\n\r\nI agree that just hyphenation (using Hyphenator.js or some
    other script) is the more practical solution right now. I'm hoping to convince
    browser authors to implement the Knuth and Plass algorithm instead of trying to
    provide this as a drop-in script. I'm looking forward to your article (is it going
    to be published at ALA again?) Are you planning on mentioning the sub-optimal
    justification done by most browsers? I was planning to write a technical article
    on that, but perhaps I don't need if you cover it as well.\r\n\r\nWith regards
    to re-rendering; almost every change to a page requires re-rendering, the question
    is where that re-rendering is executed. With Hyphenator.js it is done by the browser,
    with my implementation it is done by JavaScript. Both are doing essentially the
    same---calculating font metrics, and re-doing the justification. The greatest
    slow down in my implementation is not actually the Knuth and Plass algorithm (which
    runs very fast) but getting font metrics back from the browser. I'm currently
    not caching any of the measurements I do, so there is room for improvement there.
    There are however a myriad of other problems as you mentioned. I'm slowly working
    my way through them, but I doubt it will ever be as good as a native implementation.
    It is kind of fun to see how far I can push it though :)"
  created: '2010-07-01 14:22:26'
- author:
    name: jdaggett
  body: "One thing to note here, hyphenation controls are included in the Editor's
    Draft of the CSS3 Paged Media spec:\r\n\r\n  http://dev.w3.org/csswg/css3-gcpm/#hyphenation\r\n\r\nI
    don't know if there are any implementations of this already (Prince? Antenna House?)
    but it would interesting to hear opinions as to whether these properties cover
    the desired functionality.  The hyphenation resource property is interesting,
    it avoids the problem of how to cover a wide set of languages.  Seems like it
    might be good to include 'auto' in there, to pick up system dictionary resources
    if available."
  created: '2010-07-02 04:19:27'
- author:
    name: Richard Fink
    picture: 117375
  body: "@jdaggett\r\n\r\nThanks very much for the heads up. I'll look over that spec
    carefully.\r\nI do think Prince supports H&J but not sure how they're implementing
    it.\r\nMust look.\r\n\r\n@bram stein, frode, theunis, et al:\r\n\r\nHere's a crude
    and <a href=\"http://readableweb.com/justify/Conrad_Heart_chap1.htm\">basic page</a>,
    but with pretty decent H&J, I think.\r\nUsing a font stack of constantia, georgia,
    serif.\r\nIt's the first chapter of Joseph Conrad's Heart Of Darkness.\r\nLooking
    good in Chrome, FF, IE, Opera, Safari.\r\nYou can Page Zoom it, Text Zoom it,
    and it still holds up. (The font-size is px, so IE's text size menu won't do squat.)\r\n\r\nUses
    Sizzle as the selector engine and my own fork-in-progress of hyphenate.js.\r\nMany
    improvements to make, still, but so far, I like the results.\r\n(I would love
    some font-family/font-size/word-spacing/line-height/column-width widgets on the
    page to speed up the design process instead of bouncing back and forth from the
    style sheet to the browser. Only a matter of time, I guess.)\r\n\r\nMy next move
    might be to do a print style sheet using points and inches instead of pixel values
    and see how that pans out. Try some different stuff and print to PDF's to see
    what's coming out. Break out of the pixel grid a little.\r\n\r\nPrint stylesheets
    never got much traction - they remain largely unexplored territory. But if you
    can include a printable version of a document with really nice typography along
    with the screen version, that would seem to make a lot of sense to do. No?\r\n\r\nAnyway,
    that seems to be what the folks at Prince and Antennae House that JD mentioned
    are banking on - with PDF as the intermediary format.\r\n\r\nRich\r\n\r\n\r\n\r\n"
  created: '2010-07-03 22:32:05'
- author:
    name: dezcom
    picture: 109959
  body: Flatland was one of my favorite books as a child!
  created: '2010-07-03 23:11:51'
- author:
    name: Frode Bo Helland
    picture: 112295
  body: "This looks real nice, Richard! An external javascript file is a viable solution
    until browsers start moving.\r\n\r\nWhy not ems and/or percentage?\r\nAre there
    any issues with @font-face?"
  created: '2010-07-03 23:38:40'
- author:
    name: Theunis de Jong
    picture: 114717
  body: Your sample looks awesome! Congratulations, it looks just like a PDF from
    InDesign!
  created: '2010-07-04 00:08:10'
- author:
    name: Frode Bo Helland
    picture: 112295
  body: What does the word-spacing in the CSS have to say your method?
  created: '2010-07-04 01:21:24'
- author:
    name: riccard0
    picture: 117627
  body: '@Richard Fink (3.Jul.2010 2.32pm) It looks good even in Camino (nightly)!
    :-)'
  created: '2010-07-04 07:57:25'
- author:
    name: Richard Fink
    picture: 117375
  body: "@frode\r\n>Why not ems and/or percentage?\r\nAre there any issues with @font-face?\r\nEms
    and percentages will work fine. Remember, the font always gets rounded out to
    a pixel \"computed style\". So if ems and percentages are your preference, not
    a problem.\r\n\r\n>Are there any issues with @font-face?\r\nNo problem in IE.
    But I'm not sure what's going on with the other browsers. Last I checked, FF *did
    not* print with an @font-face font. It's an important question - I have to check
    that out.\r\n\r\n>What does the word-spacing in the CSS have to say your method?\r\nI
    just usually prefer a tighter word spacing than the browser usually provides.
    And, of course, if you tighten it up (or loosen) it will affect where the line
    breaks occur.\r\nAnd the font plays a role, too - for word-space values you should
    always use ems.\r\n\r\n@theunis\r\nwhy thanks. I've read Heart of Darkness I think,
    twice, in my life. Today I found myself reading it again. Now I'm going to have
    to set the other two chapters so I'm not frustrated.\r\n\r\n@riccard0\r\nThanks
    for checking in Camino. I just bought a Mac for the first time in my life about
    a week ago but believe it or not I haven't turned it on yet. (Been too busy and
    I want to take my time with it.)\r\nYou reminded me that soon I'll be able to
    test outside of Windows. Yay!\r\n\r\n\r\n\r\n"
  created: '2010-07-04 22:22:14'
- author:
    name: Mathias Nater
  body: "Hi\r\n\r\nThanks for all your nice words about hyphenator.js (It makes me
    feeling great;-)\r\nI just stumbled upon this very interesting discussion and
    I'd like to share some thoughts:\r\n\r\n(a) When I started the hyphenator.js-project
    I wasn't sure if it is right to do such things in Javascript. In my opinion this
    definitely should be done by the browser. But the parts of the CSS3-Specification
    treating hyphenation haven't changed for a long time and there seems not to be
    much work on it currently. So I thought it would be nice to have this 'crutch'.
    And I hope that it is used and that the demand for a native solution grows with
    it. I think that Bram Steins excellent work tends to create the same demand.\r\nAnd
    if there are some browsers supporting hyphenation and/or hq linebreaking it's
    great to have this 'crutches' for the others in the meantime.\r\n\r\n(b) As every
    JS-library guy, I'm struggling with browser flaws an inconsistencies. It's often
    hard to decide, if I should wait for the browser to fix it or if I should do a
    hack to work around it.\r\nThe issue with copy and paste is just one example.
    BTW: it's fixed. Thanks to [[http://github.com/aristus/sweet-justice|sweet-justice]]\r\n@Richard
    Fink: it's the same approach you made. We did some double work here. Are there
    more such nice things to come?\r\n\r\n(c) Many people are asking for new features.
    Meanwhile I'm trying to hold the library as small as possible and for most requests
    there are two answers: 'it's already in there' or 'it shouldn't be in there'.\r\nHaving
    a selector engine to select elements to be hyphenated is one of it. In hyphenator.js
    one can redefine the [[http://code.google.com/p/hyphenator/wiki/en_PublicAPI#property_selectorfunction|'selectorfunction']]
    so it's not necessary to include an engine that has to be loaded twice if there
    are other libs that use it.\r\n\r\n(d) I did a lot of investigation about how
    to avoid the 'shotgun method' (nice wording, though;-). The problem is that changing
    the DOM is very expensive and measuring lines and getting hints about where the
    line is broken means inserting a lot of spans (and re-doing the whole process
    upon resizings). So the actual method is ugly but turned out to be very effective.\r\n\r\nGreetings
    from Switzerland,\r\nMathias"
  created: '2010-07-05 22:53:05'
- author:
    name: John Hudson
    picture: 110397
  body: "Rich, the justified Conrad example looks really good. It even works pretty
    well on my mobile with, obviously, a narrower column and text a bit too small.\r\n\r\nBy
    the way, \u2018Justified Conrad\u2019 sounds like an indie rock band."
  created: '2010-07-06 19:11:26'
- author:
    name: Richard Fink
    picture: 117375
  body: "@John Hudson\r\nJH>It even works pretty well on my mobile with, obviously,
    a narrower column and text a bit too small.\r\n\r\nThanks.\r\nMedia Queries (CSS3)
    hold the most promise for getting the text to fit the viewport with the least
    amount of hassle. But there's stuff that can be done now, today, that will work
    pretty well, too. \r\nI played around with H&J quite a bit last year and there's
    tricks I didn't pull out for this demo. \r\nFor font sizing - unless you provide
    a Text Size widget in the page itself - we're stuck with Zoom. But it does Zoom
    and re-hyphenate without any hiccups.\r\nMakes you wonder WTF is up with iBooks,
    doesn't it?\r\n\r\n@Mathias Nater \r\n\r\nYou da man! I like the way you constructed
    hyphenator.js a lot. It's easy to follow what function is doing what. Easy to
    see where to hook in something like a selector engine, for example. Or the copy-paste
    fix. (Next problem is dealing with the right-click contextmenu.) The browser makers
    should be automatically stripping the soft-hyphens. I'm going to file bug reports
    on it and personally bug the sh-t out of them about that.\r\n>the actual method
    is ugly but turned out to be very effective\r\nIt seems wasteful but because the
    text is sure to reflow due to Zoom or Text Size or the size of the container element
    or viewport, it's the *necessary* approach.\r\nIt works.\r\n>We did some double
    work here.\r\nI was going to contact you, we should join forces, definitely. Now
    that the copy/paste issue is pretty well solved, I think H&J can fly. Even if
    it remains in JavaScript for a long time, I don't necessarily see performance
    as an issue. The javascript engines in modern browsers are incredibly fast and
    if you look at the stats, script execution time is almost never the bottleneck.\r\nHyphenator.js
    as a jQuery plug-in perhaps?\r\n\r\n(BTW - my wife's family on her mother's side
    are Swiss. Lugano. Emigrated to the states after the war. She spent summers there
    growing up.)"
  created: '2010-07-06 22:14:35'
- author:
    name: Mathias Nater
  body: ">Hyphenator.js as a jQuery plug-in perhaps?\r\nhttp://bitbucket.org/webvariants/jquery-hyphenator/wiki/Home"
  created: '2010-07-07 10:50:47'
- author:
    name: Richard Fink
    picture: 117375
  body: "@Mathias Nater\r\n>http://bitbucket.org/webvariants/jquery-hyphenator/wiki/Home\r\n\r\nThanks!
    I have to experiment with it. I'll post a page along with some other plugins that
    add some touchscroll functionality and other fun stuff.\r\n(I don't know about
    anybody else, but I find it easier to read a scrolling document if I can push
    it up slowly with my mouse acting like a finger on a touchscreen. Like you can
    do in a PDF. Makes it easier to keep my place in the text.)\r\n\r\nI also found
    out just today that the epub format can be unpacked, the individual files posted
    on a web server, and read by a javascript library.\r\n\r\nThis is all getting
    more and more interesting.\r\nBeing done <a href=\"http://threepress.org/static/epubjs/\">here</a>
    with <a href=\"http://blog.threepress.org/2009/02/09/introducing-epubjs/\">epubjs</a>.\r\n\r\nNow,
    I don't think anybody's incorporated hyphenator.js into *that* yet.\r\n\r\nHere's
    more info, it seems there are some other ePub javascript readers, too:\r\nhttp://ajaxian.com/by/topic/ebooks\r\n\r\nI'm
    going to start writing my article in earnest now, and shine a light on all this
    stuff.\r\nI'll email you and come back here, too.\r\n\r\n@frode\r\n>Are there
    any issues with @font-face?\r\nNo.\r\nAnd as far as printing I found -  testing
    in IE and Firefox - that as long as the style sheet has the right media attribute
    or @media rule: \"all\" or \"print\", an external font prints fine, too. And I'm
    able, in the print style sheet, to get the in-between font sizes: like the difference
    between 16pt, 16.5pt, and 17pt that the browser won't distinguish because everything
    has to snap to the pixel grid. (Values of 12.5 px not being allowed.)\r\nMakes
    me wonder what's going to happen when screens are high-res enough to do it, too.\r\n\r\n\r\n\r\n"
  created: '2010-07-08 00:03:10'
- author:
    name: Bram Stein
  body: "@Mathias Nater,\r\n\r\nGood to see you join the discussion! How was BachoTeX?
    I couldn't make it unfortunately.\r\n\r\nI'm not sure if I can take justification
    to the same level that you've taken hyphenation. Doing proper justification requires
    a lot of measuring and DOM modifications. What it comes down to is redoing (in
    JavaScript) most of the work the browser has already done. I'm actually surprised
    by how far I've gotten.\r\n\r\nYou said people are asking for more Hyphenator.js
    features. Here's a new one, I would like to have less features. Do you have any
    plans to make Hyphenator.js more modular? I am mainly interested in the hyphenation
    core and don't have much need for all the DOM manipulation code. You could of
    course bundle the modules in a single file for distribution like you do now.\r\n\r\n@Richard
    Fink\r\n\r\nI'm actually working on an ePub reader with proper hyphenation and
    justification, hence my interest and recent work on the subject :)\r\n\r\nDealing
    with the pixel grid has been interesting: it seems Webkit based browsers actually
    round values before they use them in their calculations while Gecko (Firefox)
    based browsers use the values and then round the result. The latter is of course
    preferred by me because I can then set word-spacing to values less than one pixel,
    and have it distribute the word-spacing evenly before snapping to the pixel grid.
    (You can do this manually in Webkit based browsers, but it is a bit more involved.)"
  created: '2010-07-08 14:54:38'
- author:
    name: Mathias Nater
  body: "@Richard Fink\r\n>Now, I don't think anybody's incorporated hyphenator.js
    into *that* yet.\r\nI think calibre has.\r\n\r\n@Bram Stein\r\nBachoTeX was great.
    Really friendly and very interesting people. The talks (at least the english ones)
    were great and led to the future. I got a bunch of work to do;-)\r\n\r\nI'll think
    about making Hyphenator.js modular. It seems to be a logical step now. But you'll
    have to be patient."
  created: '2010-07-08 22:02:36'
- author:
    name: Richard Fink
    picture: 117375
  body: "@mathias nater\r\n>I think calibre has.\r\nthanks for the info. I'll check
    it out.\r\n\r\nI was just quickly looking over the additions to version 3 - absolutely
    excellent.\r\nAdding DOM storage was a great idea. \r\nBTW - one thing of convenience
    that's easy to provide is a minified version of hyphenator.js. Can do?\r\nOr would
    you rather users do it on their own?\r\n\r\nAlso, one thing I just ran into with
    a little iPhone demo page I was playing with is the need to add an event to each
    paragraph. Where in the code might *you* see that fitting in?\r\n\r\nAnyway, great,
    great, great - (you too Bram!) - and I guess I'll start posting questions and
    suggestions on the Hyphenator.js Google Code site.\r\n\r\nRegards,\r\n\r\nRich\r\n\r\n\r\n\r\n"
  created: '2010-07-08 22:37:41'
- author:
    name: Richard Fink
    picture: 117375
  body: "Back already - just got twittered with a link to an interesting page.\r\nNeeds
    hyphenation, though!\r\n\r\nhttp://lamb.cc/typograph/\r\n\r\nrich"
  created: '2010-07-08 23:07:51'
- author:
    name: Mathias Nater
  body: "There's a tool called mergeAndPack in the bundle (http://hyphenator.googlecode.com/svn/trunk/mergeAndPack.html)\r\nIt
    merges core patterns and settings in one single file and packs it. It's really
    easy to handle but on most sites the source version is used. People don't read
    the how-to's:-)\r\n\r\nThose upcoming features (webstorage) are great. I'm planing
    to use webworkers, too. Already did some work, but it was too early. The time
    has come now\u2026\r\n\r\n"
  created: '2010-07-09 10:21:14'
- author:
    name: Richard Fink
    picture: 117375
  body: "@mn\r\nYeah, I saw the merge and pack. An excellent idea as well. There's
    a lot more optimization is to be had by cutting down the HTTP requests through
    incorporating everything into a single .js file than anything else. At least on
    the first visit, with nothing in the browser cache, that's for sure.\r\n\r\nAlso,
    as long as we're rockin' and rollin' in the optimization department, there's a
    little used default behavior in IE6, 7, and 8 (don't know about 9 yet) called
    the userData behavior that gives you expanded local storage. Like a super-large
    cookie. Sort of a precursor to webstorage.\r\n\r\nhttp://msdn.microsoft.com/en-us/library/ms531424(VS.85).aspx\r\n<em>The
    userData behavior persists information across sessions by writing to a UserData
    store. This provides a data structure that is more dynamic and has a greater capacity
    than cookies. The capacity of the UserData store depends on the security zone
    of the domain. The following table shows the maximum amount of UserData storage
    that is available for an individual document and also the total available for
    an entire domain, based on the security zone.</em>\r\n\r\nI've used it and it
    works. I'll play around with it as time allows and let you know if I think it
    can be helpful to Hyphenator.\r\n\r\nrich\r\n\r\n"
  created: '2010-07-09 19:34:09'
- author:
    name: Mathias Nater
  body: "@rich\r\n>the userData behavior that gives you expanded local storage.\r\n\r\nIE8
    does support DOM Storage (http://msdn.microsoft.com/en-us/library/cc197062(VS.85).aspx)
    and Hyphenator degrades gracefully for older versions. Adding code for non standard
    features in outdated browsers isn't the right way (imho) as long as it is degrading.\r\nSo
    there is no use for that. Thanks anyway."
  created: '2010-07-10 17:33:14'
- author:
    name: Richard Fink
    picture: 117375
  body: "@mathias\r\nWell, it would all depend on how much bang you get for the buck.
    In this case, I think you're right. Not worth the extra code for IE7 and 6. 'Twas
    just a thought.\r\n\r\nrich"
  created: '2010-07-12 12:26:52'
- author:
    name: Bram Stein
  body: "For those interested, I've fixed some of the bugs that were mentioned here
    before and created a new example: http://www.bramstein.com/projects/typeset/flatland/\r\n\r\nIt
    doesn't use external fonts so it is pretty fast (and in my measurements about
    twice as expensive as hyphenation.)"
  created: '2010-07-27 10:13:15'
- author:
    name: John Hudson
    picture: 110397
  body: "Very impressive, Bram.\r\n\r\nThe example displays in Minion on my system,
    which is a poor choice since CFF font rendering under Windows GDI is so bad."
  created: '2010-07-27 17:40:56'
- author:
    name: Theunis de Jong
    picture: 114717
  body: "John, you'll have to find a Mac to savour this:\r\n\r\n[img:sites/default/files/old-images/flatland_4779.png]\r\n\r\n--
    the Future of On-Line Reading is Upon us!\r\n\r\n(Now When Will the Ipad Follow?)"
  created: '2010-07-27 22:17:50'
- author:
    name: John Hudson
    picture: 110397
  body: "<em>you'll have to find a Mac to savour this</em>\r\n\r\nI can use Safari
    on Windows, with it\u2019s Mac rendering emulation, but a) Safari has an unnerving
    ability to crash my entire system like no other software has for a decade and
    b) I don't actually like the Mac rendering. It's better than the Windows GDI CFF
    rendering, but I suppose what I should really do is finish getting the IE9 beta
    installed on one of my machines so I can look at Bram\u2019s justification example
    in DWrite rendering."
  created: '2010-07-28 05:03:14'
- author:
    name: dberlow
  body: "Bram>There is also a proposal for a CSS3 text-justify property, but it seems
    they leave the actual justification algorithm up to the browser.\r\n\r\nSo this
    is pretty exciting. \r\n\r\nJDagget> Seems like it might be good to include 'auto'
    in there, to pick up system dictionary resources if available.\r\n\r\nI think
    it'd be cool to survey the roles of the Composer (in an old letterpress shop),
    a role which the browsers don't seem quick to embrace and foundries are not likely
    to fully play. Role 1 is computing which glyphs are required for a particular
    document (subsetting, not traditionally foundry business), Role 2 is knowing which
    of the glyphs to use when the right pairs or groups of characters occur, (with
    OT, founders and browsers can-do together, someday), Role 3's knowing how to break
    lines according to every language, including the rules of role 2, (hyphenation,
    nice like you see it here for English), so in Role 4 the composer can be getting
    even lines at a given column width if \"the boss\" says so, (justification, nice
    like you see it here for English in this font at this size, leading and line length).\r\n\r\nI
    don't know how that relates to the hooks and barbs CSS has and needs, but the
    role of the Composer is hardly diminishing over time on the web. No party in the
    modern process except the browsers can actually put it all together. Can they?\r\n\r\nI
    can't wait for the next episode.\r\n\r\nCheers!\r\n\r\n \r\n\r\n\r\n\r\n"
  created: '2010-07-28 23:22:35'
- author:
    name: Richard Fink
    picture: 117375
  body: "@bram\r\n\r\nThanks for the updated link, Bram. Looking good.\r\nI'll look
    at what you've done closely. Keep that link live.\r\n\r\n\r\nrich\r\n\r\n"
  created: '2010-08-01 15:46:01'
- author:
    name: Richard Fink
    picture: 117375
  body: "@all\r\n\r\nOne other thing - since last posting, I've done a lot playing
    around with hyphenator.js and gone off on a three week tangent of creating HTML
    e-books. I've also been looking closely at so-called E-Readers - for example -
    the Kindle's browser-like PC app.\r\n\r\nWith little effort, I can get a far,
    far better result in any modern browser than what Amazon offers with its downloadable
    app. It's not even close.\r\n\r\nWhat's wrong with this picture?\r\nGood golly,
    we've got ourselves an <em>incongruity</em>. I just love 'em.\r\n\r\nrich"
  created: '2010-08-01 16:05:53'
date: '2010-06-11 00:31:11'
node_type: forum
title: TypeSet - better justified web text

---
